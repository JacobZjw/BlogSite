<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python学习笔记（一）——学习资源及参考资料]]></title>
    <url>%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%8F%8A%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%2F</url>
    <content type="text"><![CDATA[环境：Python3基于Windows平台 参考资料： 《Python编程: 从入门到实践》 (美)EricMatthes,袁国忠——电子版传送门（提取码：269c） Python - 100天从新手到大师——Github传送门 不定期更新中······]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Python</tag>
        <tag>学习资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VS Code配置C/C++]]></title>
    <url>%2FVS-Code%E9%85%8D%E7%BD%AEC%2B%2B%2F</url>
    <content type="text"><![CDATA[在开始安装之前，请先确认你满足以下几个条件。1、首先，你有一台电脑，并且已经连接到网络。（受你当前网速的影响，安装过程可能会花费10几分钟或1个小时以上的时间。）2、其次，你的电脑硬盘有500MB的剩余空间。 下载MinGw-w64点击链接从sourceforge官网下载MinGw-w64 点击图片中的“Download Latest Version”下载最新版本的MinGW-w64。 安装MinGw-w64下载完成后，你会看到这样的窗口，猜猜点哪个！ 猜到正确答案的小朋友会看到这样的窗口 ! 按照这个选 然后你会看到这个： 可以根据需要在红框内更改安装路径。如果不需要改安装路径直接点下一步即可。 等待一会儿，等待的时间取决于你的网速，如果嫌太慢可以把电脑砸了。 稍微等一会你就会看到这个窗口： 这说明MinGw-w64已经下载完成： 配置环境变量在此电脑图标处点击鼠标右键，选择属性：打开系统面板。 ! 点击红框中的高级系统设置。 点击环境变量 选择红框中的Path后点击编辑 点击编辑按钮，填入bin文件夹的路径 。bin文件夹在哪？找一找你MinGW-w64的安装目录。 检查是否安装成功进入命令提示符界面输入gcc -v（命令提示符界面怎么进呢？你猜猜？），之后如果出现红框内的字符说明你已功德圆满了。 安装VS Code怎么安装？ 安装CPPTools插件优秀的你已成功安装了VS Code，接下来依次点击即可： 修改VS Code调试配置文件在系统任意位置新建一个文件夹，在VSCode打开该文件夹，然后新建一个CPP文件，写一个简单但是完整的代码，比如像我这样的。 然后在.vscode文件夹下创建四个文件，文件名为： 1234c_cpp_properties.jsonlaunch.jsonsettings.jsontasks.json 每个文件下的代码如下： c_cpp_properties.json:(文件路径需修改) 123456789101112131415161718192021222324252627&#123; "configurations": [ &#123; "name": "MinGW64", "intelliSenseMode": "gcc-x64", "compilerPath": "D:\\软件\\MinGW\\mingw64\\bin\\g++.exe", "includePath": [ "$&#123;workspaceFolder&#125;", "D:/软件/MinGW/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/**", "D:/软件/MinGW/mingw64/x86_64-w64-mingw32/include/**" ], "browse": &#123; "path": [ "$&#123;workspaceFolder&#125;", "D:/软件/MinGW/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/**", "D:/软件/MinGW/mingw64/x86_64-w64-mingw32/include/**" ] &#125;, "limitSymbolsToIncludedHeaders": true, "databaseFilename": "", "cStandard": "c11", "cppStandard": "c++17" &#125; ], "version": 4&#125; launch.json： 123456789101112131415161718192021222324252627&#123; "version": "0.2.0", "configurations": [ &#123; "name": "C++ Launch (GDB)", // 配置名称，将会在启动配置的下拉菜单中显示 "type": "cppdbg", // 配置类型，这里只能为cppdbg "request": "launch", // 请求配置类型，可以为launch（启动）或attach（附加） "targetArchitecture": "x64", // 生成目标架构，一般为x86或x64 "program": "$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe", // 重点！将要进行调试的程序的路径 "args": [], // 程序调试时传递给程序的命令行参数，一般设为空即可 "stopAtEntry": false, // 设为true时程序将暂停在程序入口处，一般设置为false "cwd": "$&#123;workspaceRoot&#125;", // 调试程序时的工作目录，一般为$&#123;workspaceRoot&#125; "externalConsole": true, // 调试时是否显示控制台窗口，一般设置为true显示控制台 "internalConsoleOptions": "neverOpen", // 如果不设为neverOpen，调试时会跳到“调试控制台”选项卡", "MIMode": "gdb", // 指定连接的调试器 "miDebuggerPath": "D:\\软件\\MinGW\\mingw64\\bin\\gdb.exe", //重点！ 调试器路径 "setupCommands": [ &#123; "description": "Enable pretty-printing for GDB", "text": "-enable-pretty-printing", "ignoreFailures": false &#125; ], "preLaunchTask": "Compile" &#125; ]&#125; settings.json: 123&#123; &quot;C_Cpp.intelliSenseEngineFallback&quot;: &quot;Enabled&quot;&#125; tasks.json: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#123; "version": "2.0.0", "tasks": [ &#123; "label": "Compile", "command": "g++", "args": [ "$&#123;file&#125;", //指定编译源代码文件 "-o", "$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe", //重点！ 指定输出文件名，不加该参数则默认输出a.exe "-ggdb3", // 生成和调试有关的信息 "-Wall", // 开启额外警告 "-static-libgcc", // 静态链接 "-std=c++17", // 使用c++17标准 "-finput-charset=UTF-8", //输入编译器文本编码 默认为UTF-8 "-fexec-charset=GBK", //输出exe文件的编码 "-D _USE_MATH_DEFINES" ], "problemMatcher": &#123; "owner": "cpp", "fileLocation": [ "absolute", ], "pattern": &#123; "regexp": "^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$", "file": 1, "line": 2, "column": 3, "severity": 4, "message": 5 &#125; &#125;, "type": "shell", "group": &#123; "kind": "build", "isDefault": true &#125;, "presentation": &#123; "echo": true, "reveal": "always", // 在“终端”中显示编译信息的策略，可以为always，silent，never "focus": false, "panel": "shared" // 不同的文件的编译信息共享一个终端面板 &#125;, &#125; ]&#125; 配置完以上文件后，直接编译运行就可以了。 如果遇到问题请留言，我会一一解答！]]></content>
      <tags>
        <tag>教程</tag>
        <tag>VS Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[malloc函数详解]]></title>
    <url>%2Fmalloc%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[函数定义及原理函数定义123extern void *malloc(unsigned int num_bytes);//函数原型#include&lt;stdlib.h&gt;//头文件void *malloc(size_t size);//函数声明 原理malloc函数接收一个参数：所需的内存字节数。malloc会根据这个参数找到合适的空闲内存块，然后返回动态内存块的首字节地址。这个内存块是匿名的，malloc函数并不会为其赋名。因此我们需要将该地址赋值给一个指针变量，然后通过指针变量来访问这块内存。 如果内存分配成功，malloc函数会返回一个（void*）类型的指针，在C、C++中规定该指针可以被强制转换成任何类型的指针，因此malloc函数可以用于返回指向数组的指针、指向结构的指针等而不用考虑类型匹配的问题。 如果内存分配失败，则会返回空指针（NULL）。利用这个特性，我们必须在每次使用malloc函数后检查内存是否分配成功。 使用malloc函数创建动态数组12double * ptd;ptd = (double*)malloc(30 * sizeof(double)); 这段代码中，malloc函数为30个double类型的值请求内存空间，然后使用强制类型转换将返回的指针转换成（double*）类型，然后赋值给ptd，即设置ptd指向所分配内存块的首元素。回忆数组的定义，数组名即为数组首元素的地址。我们将ptd指向内存块的首元素，便可以像使用数组名一样使用它。即用ptd[0]访问内存块的首元素，用ptd[1]访问内存块的第二个元素······ 利用这个方法可以创建动态数组 1double ptd[n]; 通常我们执行程序时程序会报错（C99后可以使用），因此我们可以使用以下方法来创建动态数组： 1double *ptd = ptd = (double*)malloc( n * sizeof(double)); free函数内存泄漏在C语言中，通常把变量分为静态存储变量和动态存储变量两类。静态存储变量是指在程序运行期间分配了固定存储空间的变量；动态存储变量是指在程序运行期间根据实际需要进行动态地分配存储空间的变量。在内存中供用户使用的内存空间分为三部分： 程序存储区 静态存储区 动态存储区 程序中使用的数据分别存放在静态存储区和动态存储区中，静态存储区数据在程序的开始就分配好内存区。也就是说静态内存的数量在编译时时固定的，在程序运行期间也不会改变，在程序结束时自动释放。但是动态内存的数量只会增加，除非使用free进行释放。我们来看一段程序： 1234567891011121314...int main()&#123; double glad[2000]; int i; ... for(int i=0;i&lt;1000;i++) gobble(glad,2000); ...&#125;void gobble(double ar[],int n)&#123; double * temp =(double*)malloc(n*sizeof(double));&#125; 在第一次调用gobble函数时，它创建了一个指针temp，并为其分配了8*2000=16000字节的内存，在函数结束时，作为自动变量的指针temp会消失，但是系统并不会为我们自动释放这16000字节的内存。因此这块内存区域依旧存在，但由于temp指针已经消失，因此无法访问这块内存空间，同时它也无法被重复使用。 主函数多次调用了gobble函数，当for循环执行结束，程序总共调用了1000次gobble函数，也就造成了16000000字节的内存被占用而无法使用，通常我们称这类问题为内存泄漏。为了避免这类问题，我们需要在函数末尾使用free函数来释放内存以避免这类问题的发生。 使用方法free函数的参数是一个指针，即之前malloc函数返回的地址。使用时将其放在函数的末尾。例如上述代码添加free函数： 12345void gobble(double ar[],int n)&#123; double * temp =(double*)malloc(n*sizeof(double)); free(temp);&#125; free函数使用的指针变量可以与malloc函数的指针变量不同，但是两个指针变量必须储存相同的地址。另外，如果被调函数使用malloc函数分配内存空间并返回指针供主调函数使用，则可以在主调函数末尾使用free函数通过该指针释放被调函数创建的内存空间，也就是说内存块可以在一个函数中创建，在另一个函数中销毁。需要注意的是，不能释放同一内存块两次。 其他相关函数的使用calloc函数calloc函数功能与malloc函数类似，其典型用法如下： 1double * temp = (double *)calloc(1000,sizeof(double)) calloc函数的参数是两个无符号整数，第一个参数是所需的存储单元数量，第二个参数是每个存储单元的大小。calloc函数有个特性，即在动态分配完内存后，自动初始化该内存空间为零，而malloc不初始化，里边数据是随机的垃圾数据。这是calloc与malloc最主要的区别。free函数也可以用于释放calloc分配的内存空间。 realloc函数当我们动态分配的内存不够了或者过大，我们可以使用realloc函数来调整内存的大小。其基本语法为： 指针名=（数据类型*）realloc(要改变内存大小的指针名，新的大小) 如果新的大小小于原内存大小，可能会导致数据的丢失；如果新的内存大小大于原内存大小，新分配的部分不会被初始化。 其原理时先判断当前指针是否有足够的连续内存空间，如果有则扩大当前地址，返回当前的指针；如果没有，则根据指定的内存大小重新寻找并分配内存空间，然后将原有数据全部拷贝至新的内存块，并自动释放原来的内存，然后返回新的内存块的首地址。 如果重新分配成功则返回指向被分配内存的指针，分配失败则返回空指针（NULL）。在函数结束时同样要使用free函数来释放内存空间。 参考资料 百度百科”realloc” 百度百科”malloc” 《C Primer Plus》（第6版）中文版]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pop Sequence]]></title>
    <url>%2FPop%20Sequence%2F</url>
    <content type="text"><![CDATA[Pop Sequence题目Given a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, …, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4. 输入格式Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M (the maximum capacity of the stack), N (the length of push sequence), and K (the number of pop sequences to be checked). Then T lines follow, each contains a pop sequence of N numbers. All the numbers in a line are separated by a space. 输出格式For each pop sequence, print in one line “YES“ if it is indeed a possible pop sequence of the stack, or “NO“ if not. 输入示例1234565 7 51 2 3 4 5 6 73 2 1 7 5 6 47 6 5 4 3 2 15 6 4 3 7 2 11 7 6 5 4 3 2 输出示例12345YESNONOYESNO 题目分析题目大意是给定一个入栈序列1，2，3，…，N，限定栈的大小为M，要求判断序列是否有可能从该栈输出。 例如题目所给的样例：5 6 4 3 7 2 1： 我们根据第一个出栈元素为5可以判断在5出栈前，1 2 3 4都应已入栈，则下一个应入栈元素是6。 根据第二个元素为6可知，6出栈前栈里的元素为1 2 3 4 6；下一个进栈元素是7。 根据第三个元素是4，第四个元素是3可知，7进栈前栈里的元素是1 2 ；7出栈后2，1分别出栈。整个过程符合1，2，3，…，N的入栈顺序，故该序列合法。 因此，若出现【栈顶元素大于待出栈的元素】或者【栈顶元素小于待出栈的元素】但【栈已满】的情况，则说明这个待出栈的元素是不可能出现的，据此可以判断该出栈序列不合法。 代码实现链表栈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;typedef struct node&#123; int *base; int top; int size;&#125;*stack;int m, n, t;stack CreateStack(int size)&#123; stack s = (stack)malloc(sizeof(struct node)); s-&gt;base = (int*)malloc(size * sizeof(int)); if (!s-&gt;base) &#123; cout &lt;&lt; "ERROR" &lt;&lt; endl; return 0; &#125; s-&gt;top = 0; s-&gt;size = size; return s;&#125;void push(stack s,int e)&#123; if (s-&gt;top == s-&gt;size)//栈已满 &#123; cout &lt;&lt; "FULL" &lt;&lt; endl; return ; &#125; s-&gt;base[++(s-&gt;top)] = e; return ;&#125;void pop(stack s)&#123; if (s-&gt;top == 0)//栈为空 &#123; cout &lt;&lt; "EMPTY" &lt;&lt; endl; return ; &#125; s-&gt;top--;&#125;int Check(int *array, stack s)&#123; int now = 1; int flag = 1; s-&gt;top = 0;//注意这里要重新设置栈顶位置 for (int i = 0; i &lt; n &amp;&amp; flag; i++) &#123; while ((s-&gt;base[s-&gt;top] != array[i] || s-&gt;top == 0)&amp;&amp;flag)//【栈为空】或【栈顶元素与待比较的出栈元素不等】 &#123; push(s, now); if (s-&gt;top==s-&gt;size &amp;&amp; s-&gt;base[s-&gt;top] != array[i]) //若【栈已满且栈顶元素仍然小于待比较的出栈元素】 &#123; flag = 0; break; &#125; now++; &#125; if ( flag &amp;&amp; s-&gt;base[s-&gt;top] == array[i] &amp;&amp; s-&gt;top &gt;= 1)//若【栈非空且栈顶元素等于待比较的出栈元素】 pop(s); &#125; if (flag) cout &lt;&lt; "YES" &lt;&lt; endl; else cout &lt;&lt; "NO" &lt;&lt; endl; return 1;&#125;int main()&#123; cin &gt;&gt; m &gt;&gt; n &gt;&gt; t; int *array = (int*)malloc(n * sizeof(int)); stack s = CreateStack(m); while (t--) &#123; for (int i = 0; i &lt; n; i++) cin &gt;&gt; array[i]; Check(array, s); &#125; free(s-&gt;base); free(array); return 0;&#125; 数组栈1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;using namespace std;int main()&#123; int m, n, t; cin &gt;&gt; m &gt;&gt; n &gt;&gt; t; int stack[1005];//栈 while (t--)//遍历每一个序列 &#123; int top = 0;//栈顶元素 int num;//待比较的出栈元素 int flag = 1;//判断标志 int now = 1; for (int i = 0; i &lt; n; i++)//遍历每一个数 &#123; cin &gt;&gt; num; while ((top == 0 || num != stack[top]) &amp;&amp; flag)//栈为空或者待出栈元素与栈顶元素不相等 &#123; stack[++top] = now; if (top &gt; m) &#123; flag = 0; break; &#125; now++; &#125; if (num == stack[top] &amp;&amp; flag &amp;&amp; top &gt;= 1)//栈不为空且...... &#123; top--; &#125; &#125; if (flag) printf("YES\n"); else printf("NO\n"); &#125;&#125;]]></content>
      <tags>
        <tag>习题</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String Task]]></title>
    <url>%2FString-Task%2F</url>
    <content type="text"><![CDATA[题目A. String TaskPetya started to attend programming lessons. On the first lesson his task was to write a simple program. The program was supposed to do the following: in the given string, consisting if uppercase and lowercase Latin letters, it: deletes all the vowels, inserts a character “.” before each consonant, replaces all uppercase consonants with corresponding lowercase ones. Vowels are letters “A”, “O”, “Y”, “E”, “U”, “I”, and the rest are consonants. The program’s input is exactly one string, it should return the output as a single string, resulting after the program’s processing the initial string. Help Petya cope with this easy task. InputThe first line represents input string of Petya’s program. This string only consists of uppercase and lowercase Latin letters and its length is from 1 to 100, inclusive. OutputPrint the resulting string. It is guaranteed that this string is not empty. 题解给定字符串，包含大小写的拉丁字母 删除所有元音， 在每个辅音之前插入“ . ”， 将所有大写辅音替换成相应的小写辅音； 元音字母包含 A，O，Y，E，U，I； 程序输入是一个字符串，它以单个字符串的形式返回输出，这是程序处理初始字符串后的结果 Input 第一行表示输入的字符串，改字符串仅由大写和小写拉丁字母组成，长度从0~100；Output打印结果字符串，可以保证这个字符串不为空。 思路​ 分别定义一个输入的字符串in[100]和输出的字符串ou[100]，将输出的字符串ou[100]的所有字符初始化为 ‘ . ‘ ；然后先将输入字符串的所有大写字母转换为小写；之后通过if语句判断是否为辅音字母；是辅音字母则间位提取至输出字符串ou[100]中。最后所得到的ou[100]则可以直接输出。 代码实现12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;int main()&#123; char in[100],ou[100]; for (int i = 0; i &lt; 100; i++) ou[i] = '.'; cin &gt;&gt;in; int j = 1, num = 0; for (int i = 0; i &lt; strlen(in);i++)//逐个查找 &#123; if (in[i] &gt;= 65 &amp;&amp; in[i] &lt;= 90) in[i] += 32;//将所有字母转换成小写 if (in[i] != 'a' &amp;&amp; in[i] != 'o' &amp;&amp; in[i] != 'y' &amp;&amp; in[i] != 'e' &amp;&amp; in[i] != 'u' &amp;&amp;in[i] != 'i') &#123; ou[j] = in[i]; num++; j += 2; &#125;//如果是辅音则间位提取 &#125; for (j = 0; j &lt; 2 * num; j++) cout &lt;&lt; ou[j]; cout &lt;&lt; endl; system("pause");&#125;]]></content>
      <tags>
        <tag>习题</tag>
      </tags>
  </entry>
</search>
