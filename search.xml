<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python学习笔记（二）——数字类型的运算及其输入与格式化输出]]></title>
    <url>%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BF%90%E7%AE%97%E5%8F%8A%E5%85%B6%E8%BE%93%E5%85%A5%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[数字类型python中数字有四种类型：整数、布尔型、浮点数和复数。 int (整型), 如 1, 只有一种整数类型 int，表示为长整型，没有python2 中的 long。 bool (布尔型), 如True。 float (浮点型), 如 1.23、3E-2 complex (复数型), 如 1 + 2j、 1.1 + 2.2j 整型Python中可以处理任意大小（即无限大小）的整数（Python 2.x中有int和long两种类型的整数，但这种区分对Python来说意义不大，因此在Python 3.x中整数只有int这一种了），而且支持二进制（如0b100，换算成十进制是4）、八进制（如0o100，换算成十进制是64）、十进制（100）和十六进制（0x100，换算成十进制是256）的表示法。 布尔型布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来（例如3 &lt; 5会产生布尔值True，而2 == 1会产生布尔值False）。 浮点型Python将带小数点的数字统称为浮点数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如123.456）之外还支持科学计数法（如1.23456e2）。 复数型形如3+5j，跟数学上的复数表示一样，唯一不同的是虚部的i换成了j。 运算符及运算算术运算符 运算符 描述 + 加——两个对象相加 - 减——一个数减去另一个数 * 乘——两个数相乘或者的到一个被重复若干次的字符串 / 除——x除以y % 取模——返回除法的余数 ** 幂——返回x的y次幂 // 取整数——返回商的余数 示例： 123456789a=121b=10print('%d + %d =\t%d' %(a,b,a+b))#相加print('%d - %d =\t%d' %(a,b,a-b))#相减print('%d * %d =\t%d' %(a,b,a*b))#相乘print('%d / %d = \t%f' % (a, b, a / b))#相除print('%d // %d = \t%d' % (a, b, a // b))#整除print('%d %% %d = \t%d' % (a, b, a % b))#取模print('%d ** %d = \t%d' % (a, b, a ** b))#幂 运算结果： 1234567121 + 10 = 131121 - 10 = 111121 * 10 = 1210121 / 10 = 12.100000121 // 10 = 12121 % 10 = 1121 ** 10 = 672749994932560009201 赋值运算符 运算符 描述 = c=a+b将a+b运算结果赋值为c += c+=a等价于c=c+a -= c-=a等价于c=c-a *= c*=a等价于c=c*a /= c/=a等价于c=c/a %= c%=a等价于c=c%a **= c* * =a等价于c=c* *a //= c//=a等价于c=c//a 逻辑运算符Python语言支持以下逻辑运算符。假设变量a的值为True，变量b的值为False，那么 - 运算符 描述 示例 and 如果两个操作数都为真，则条件成立。 (a and b)的结果为False or 如果两个操作数中的任何一个非零，则条件成为真。 (a or b)的结果为True not 用于反转操作数的逻辑状态。 not(a and b) 的结果为True 示例： 123456789101112flag1 = 3 &gt; 2flag2 = 2 &lt; 1flag3 = flag1 and flag2flag4 = flag1 or flag2flag5 = not flag1print("flag1 = ", flag1)print("flag2 = ", flag2)print("flag3 = ", flag3)print("flag4 = ", flag4)print("flag5 = ", flag5)print(flag1 is True)print(flag2 is not False) 运算结果： 1234567flag1 = Trueflag2 = Falseflag3 = Falseflag4 = Trueflag5 = FalseTrueFalse 按位运算符设变量a=60,b=13;则二进制a表示为：00111100，b表示为：00001101 运算符 描述 示例 &amp; 二进制与。如果它存在于两个操作数中，则操作符复制位到结果中 (a &amp; b) 结果表示为 00001100 ` ` 二进制或，如果它存在于任一操作数，则复制位。 `(a b)=61结果表示为00111101` ^ 二进制异或，如果它是一个操作数集合，但不是同时是两个操作数则将复制位。 (a ^ b) = 49 结果表示为 00110001 ~ 二进制补码，它是一元的，具有“翻转”的效果。 (~a ) = -61有符号的二进制数，表示为11000011的补码形式 &lt;&lt; 二进制左移，左操作数的值由右操作数指定的位数左移。 a &lt;&lt; 2 = 240 结果表示为 11110000 &gt;&gt; 二进制右移，左操作数的值由右操作数指定的位数右移。 a &gt;&gt; 2 = 15结果表示为00001111 Python的内置函数bin()可用于获取整数的二进制表示形式。 示例： 12345678910111213141516171819202122a = 60 # 60 = 0011 1100b = 13 # 13 = 0000 1101print ('a=',a,':',bin(a),'b=',b,':',bin(b))c = 0c = a &amp; b; # 12 = 0000 1100print ("result of AND is ", c,':',bin(c))c = a | b; # 61 = 0011 1101 print ("result of OR is ", c,':',bin(c))c = a ^ b; # 49 = 0011 0001print ("result of EXOR is ", c,':',bin(c))c = ~a; # -61 = 1100 0011print ("result of COMPLEMENT is ", c,':',bin(c))c = a &lt;&lt; 2; # 240 = 1111 0000print ("result of LEFT SHIFT is ", c,':',bin(c))c = a &gt;&gt; 2; # 15 = 0000 1111print ("result of RIGHT SHIFT is ", c,':',bin(c)) 运算结果： 1234567a= 60 : 0b111100 b= 13 : 0b1101result of AND is 12 : 0b1100result of OR is 61 : 0b111101result of EXOR is 49 : 0b110001result of COMPLEMENT is -61 : -0b111101result of LEFT SHIFT is 240 : 0b11110000result of RIGHT SHIFT is 15 : 0b1111 成员运算符 运算符 描述 in 如果在指定的序列中找到一个变量的值，则返回true，否则返回false。 not int 如果在指定序列中找不到变量的值，则返回true，否则返回false。 身份运算符 运算符 描述 is 如果运算符任一侧的变量指向相同的对象，则返回True，否则返回False。 is not 如果运算符任一侧的变量指向相同的对象，则返回True，否则返回False。 基本输入与格式化输出输入使用input([prompt])读取一行，将其转换为string类型并返回。input的参数可有可无，如果有参数的话，会在控制台（可以这样理解）输出参数的内容，不换行。通常情况下我们在控制台输入一些数据，然后敲击回车，就完成了本次输入。 示例： 12name = input("Please enter your name: ")print(name) 运算结果： 12Please enter your name: JacobJacob 这里要注意的是，input返回的是string类型，如果想输入数字，还需要进行类型转换，例如： 12num = int(input("Enter a number: "))print(num*2) 运算结果： 12Enter a number: 48 格式化输出Python字符串格式化符号： 符号 描述 %c 格式化字符及其ASCII码 %s 格式化字符串 %d 格式化整数 %u 格式化无符号整型 %o 格式化无符号八进制数 %x 格式化无符号十六进制数 %X 格式化无符号十六进制数（大写） %f 格式化浮点数字，可指定小数点后的精度 %e 用科学计数法格式化浮点数 %E 作用同%e，用科学计数法格式化浮点数 %g %f和%e的简写 %G %f 和 %E 的简写 %p 用十六进制数格式化变量的地址 格式化操作符辅助指令： 符号 功能 * 定义宽度或者小数点精度 - 用做左对齐 + 在正数前面显示加号( + )，在负数前面显示减号（-） 在正数前面显示空格 # 在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’) 0 显示的数字前面填充’0’而不是默认的空格 % ‘%%’输出一个单一的’%’ (var) 映射变量(字典参数) m.n. m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话) 格式化输出整数示例： 12345678a = 321b = 123print(a + b)print('%d + %d = %d' % (a, b, a + b))print('%d + %d = %+d' % (a, b, a + b))print('%d + %d = %06d' % (a, b, a + b))print('%d + %d = %.6d' % (a, b, a + b))print("a + b= ",a+b) 运算结果： 123456444321 + 123 = 444321 + 123 = +444321 + 123 = 000444321 + 123 = 000444a + b= 444 格式化输出16进制，十进制，八进制整数#%x — hex 十六进制 #%d — dec 十进制 #%o — oct 八进制 示例： 1234nHex = 1024print("nHex = %x,nDec = %d,nOct = %o" %(nHex,nHex,nHex))nHex = 0xFFprint("nHex = %x,nDec = %d,nOct = %o" %(nHex,nHex,nHex)) 运算结果： 12nHex = 400,nDec = 1024,nOct = 2000nHex = ff,nDec = 255,nOct = 377 格式化输出浮点数示例： 12345678pi = 3.141592653 print('%10.3f' % pi) #字段宽10，精度3 print("pi = %.*f" % (3,pi)) #用*从后面的元组中读取字段宽度或精度 print('%010.3f' % pi) #用0填充空白 print('%-10.3f' % pi) #左对齐 print('%+f' % pi) #显示正负号 pi = -piprint('%+f' % pi) #显示正负号 运算结果： 123456 3.142pi = 3.142000003.1423.142+3.141593-3.141593]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记（一）——学习资源及参考资料]]></title>
    <url>%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%8F%8A%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%2F</url>
    <content type="text"><![CDATA[环境：Python3基于Windows平台 参考资料： 《Python编程: 从入门到实践》 (美)EricMatthes,袁国忠——电子版传送门（提取码：269c） Python - 100天从新手到大师——Github传送门 不定期更新中······]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Python</tag>
        <tag>学习资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VS Code配置C/C++]]></title>
    <url>%2FVS-Code%E9%85%8D%E7%BD%AEC%2B%2B%2F</url>
    <content type="text"><![CDATA[在开始安装之前，请先确认你满足以下几个条件。1、首先，你有一台电脑，并且已经连接到网络。（受你当前网速的影响，安装过程可能会花费10几分钟或1个小时以上的时间。）2、其次，你的电脑硬盘有500MB的剩余空间。 下载MinGw-w64点击链接从sourceforge官网下载MinGw-w64 点击图片中的“Download Latest Version”下载最新版本的MinGW-w64。 安装MinGw-w64下载完成后，你会看到这样的窗口，猜猜点哪个！ 猜到正确答案的小朋友会看到这样的窗口 ! 按照这个选 然后你会看到这个： 可以根据需要在红框内更改安装路径。如果不需要改安装路径直接点下一步即可。 等待一会儿，等待的时间取决于你的网速，如果嫌太慢可以把电脑砸了。 稍微等一会你就会看到这个窗口： 这说明MinGw-w64已经下载完成： 配置环境变量在此电脑图标处点击鼠标右键，选择属性：打开系统面板。 ! 点击红框中的高级系统设置。 点击环境变量 选择红框中的Path后点击编辑 点击编辑按钮，填入bin文件夹的路径 。bin文件夹在哪？找一找你MinGW-w64的安装目录。 检查是否安装成功进入命令提示符界面输入gcc -v（命令提示符界面怎么进呢？你猜猜？），之后如果出现红框内的字符说明你已功德圆满了。 安装VS Code怎么安装？ 安装CPPTools插件优秀的你已成功安装了VS Code，接下来依次点击即可： 修改VS Code调试配置文件在系统任意位置新建一个文件夹，在VSCode打开该文件夹，然后新建一个CPP文件，写一个简单但是完整的代码，比如像我这样的。 然后在.vscode文件夹下创建四个文件，文件名为： 1234c_cpp_properties.jsonlaunch.jsonsettings.jsontasks.json 每个文件下的代码如下： c_cpp_properties.json:(文件路径需修改) 123456789101112131415161718192021222324252627&#123; "configurations": [ &#123; "name": "MinGW64", "intelliSenseMode": "gcc-x64", "compilerPath": "D:\\软件\\MinGW\\mingw64\\bin\\g++.exe", "includePath": [ "$&#123;workspaceFolder&#125;", "D:/软件/MinGW/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/**", "D:/软件/MinGW/mingw64/x86_64-w64-mingw32/include/**" ], "browse": &#123; "path": [ "$&#123;workspaceFolder&#125;", "D:/软件/MinGW/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/**", "D:/软件/MinGW/mingw64/x86_64-w64-mingw32/include/**" ] &#125;, "limitSymbolsToIncludedHeaders": true, "databaseFilename": "", "cStandard": "c11", "cppStandard": "c++17" &#125; ], "version": 4&#125; launch.json： 123456789101112131415161718192021222324252627&#123; "version": "0.2.0", "configurations": [ &#123; "name": "C++ Launch (GDB)", // 配置名称，将会在启动配置的下拉菜单中显示 "type": "cppdbg", // 配置类型，这里只能为cppdbg "request": "launch", // 请求配置类型，可以为launch（启动）或attach（附加） "targetArchitecture": "x64", // 生成目标架构，一般为x86或x64 "program": "$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe", // 重点！将要进行调试的程序的路径 "args": [], // 程序调试时传递给程序的命令行参数，一般设为空即可 "stopAtEntry": false, // 设为true时程序将暂停在程序入口处，一般设置为false "cwd": "$&#123;workspaceRoot&#125;", // 调试程序时的工作目录，一般为$&#123;workspaceRoot&#125; "externalConsole": true, // 调试时是否显示控制台窗口，一般设置为true显示控制台 "internalConsoleOptions": "neverOpen", // 如果不设为neverOpen，调试时会跳到“调试控制台”选项卡", "MIMode": "gdb", // 指定连接的调试器 "miDebuggerPath": "D:\\软件\\MinGW\\mingw64\\bin\\gdb.exe", //重点！ 调试器路径 "setupCommands": [ &#123; "description": "Enable pretty-printing for GDB", "text": "-enable-pretty-printing", "ignoreFailures": false &#125; ], "preLaunchTask": "Compile" &#125; ]&#125; settings.json: 123&#123; &quot;C_Cpp.intelliSenseEngineFallback&quot;: &quot;Enabled&quot;&#125; tasks.json: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#123; "version": "2.0.0", "tasks": [ &#123; "label": "Compile", "command": "g++", "args": [ "$&#123;file&#125;", //指定编译源代码文件 "-o", "$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe", //重点！ 指定输出文件名，不加该参数则默认输出a.exe "-ggdb3", // 生成和调试有关的信息 "-Wall", // 开启额外警告 "-static-libgcc", // 静态链接 "-std=c++17", // 使用c++17标准 "-finput-charset=UTF-8", //输入编译器文本编码 默认为UTF-8 "-fexec-charset=GBK", //输出exe文件的编码 "-D _USE_MATH_DEFINES" ], "problemMatcher": &#123; "owner": "cpp", "fileLocation": [ "absolute", ], "pattern": &#123; "regexp": "^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$", "file": 1, "line": 2, "column": 3, "severity": 4, "message": 5 &#125; &#125;, "type": "shell", "group": &#123; "kind": "build", "isDefault": true &#125;, "presentation": &#123; "echo": true, "reveal": "always", // 在“终端”中显示编译信息的策略，可以为always，silent，never "focus": false, "panel": "shared" // 不同的文件的编译信息共享一个终端面板 &#125;, &#125; ]&#125; 配置完以上文件后，直接编译运行就可以了。 如果遇到问题请留言，我会一一解答！]]></content>
      <tags>
        <tag>教程</tag>
        <tag>VS Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[malloc函数详解]]></title>
    <url>%2Fmalloc%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[函数定义及原理函数定义123extern void *malloc(unsigned int num_bytes);//函数原型#include&lt;stdlib.h&gt;//头文件void *malloc(size_t size);//函数声明 原理malloc函数接收一个参数：所需的内存字节数。malloc会根据这个参数找到合适的空闲内存块，然后返回动态内存块的首字节地址。这个内存块是匿名的，malloc函数并不会为其赋名。因此我们需要将该地址赋值给一个指针变量，然后通过指针变量来访问这块内存。 如果内存分配成功，malloc函数会返回一个（void*）类型的指针，在C、C++中规定该指针可以被强制转换成任何类型的指针，因此malloc函数可以用于返回指向数组的指针、指向结构的指针等而不用考虑类型匹配的问题。 如果内存分配失败，则会返回空指针（NULL）。利用这个特性，我们必须在每次使用malloc函数后检查内存是否分配成功。 使用malloc函数创建动态数组12double * ptd;ptd = (double*)malloc(30 * sizeof(double)); 这段代码中，malloc函数为30个double类型的值请求内存空间，然后使用强制类型转换将返回的指针转换成（double*）类型，然后赋值给ptd，即设置ptd指向所分配内存块的首元素。回忆数组的定义，数组名即为数组首元素的地址。我们将ptd指向内存块的首元素，便可以像使用数组名一样使用它。即用ptd[0]访问内存块的首元素，用ptd[1]访问内存块的第二个元素······ 利用这个方法可以创建动态数组 1double ptd[n]; 通常我们执行程序时程序会报错（C99后可以使用），因此我们可以使用以下方法来创建动态数组： 1double *ptd = ptd = (double*)malloc( n * sizeof(double)); free函数内存泄漏在C语言中，通常把变量分为静态存储变量和动态存储变量两类。静态存储变量是指在程序运行期间分配了固定存储空间的变量；动态存储变量是指在程序运行期间根据实际需要进行动态地分配存储空间的变量。在内存中供用户使用的内存空间分为三部分： 程序存储区 静态存储区 动态存储区 程序中使用的数据分别存放在静态存储区和动态存储区中，静态存储区数据在程序的开始就分配好内存区。也就是说静态内存的数量在编译时时固定的，在程序运行期间也不会改变，在程序结束时自动释放。但是动态内存的数量只会增加，除非使用free进行释放。我们来看一段程序： 1234567891011121314...int main()&#123; double glad[2000]; int i; ... for(int i=0;i&lt;1000;i++) gobble(glad,2000); ...&#125;void gobble(double ar[],int n)&#123; double * temp =(double*)malloc(n*sizeof(double));&#125; 在第一次调用gobble函数时，它创建了一个指针temp，并为其分配了8*2000=16000字节的内存，在函数结束时，作为自动变量的指针temp会消失，但是系统并不会为我们自动释放这16000字节的内存。因此这块内存区域依旧存在，但由于temp指针已经消失，因此无法访问这块内存空间，同时它也无法被重复使用。 主函数多次调用了gobble函数，当for循环执行结束，程序总共调用了1000次gobble函数，也就造成了16000000字节的内存被占用而无法使用，通常我们称这类问题为内存泄漏。为了避免这类问题，我们需要在函数末尾使用free函数来释放内存以避免这类问题的发生。 使用方法free函数的参数是一个指针，即之前malloc函数返回的地址。使用时将其放在函数的末尾。例如上述代码添加free函数： 12345void gobble(double ar[],int n)&#123; double * temp =(double*)malloc(n*sizeof(double)); free(temp);&#125; free函数使用的指针变量可以与malloc函数的指针变量不同，但是两个指针变量必须储存相同的地址。另外，如果被调函数使用malloc函数分配内存空间并返回指针供主调函数使用，则可以在主调函数末尾使用free函数通过该指针释放被调函数创建的内存空间，也就是说内存块可以在一个函数中创建，在另一个函数中销毁。需要注意的是，不能释放同一内存块两次。 其他相关函数的使用calloc函数calloc函数功能与malloc函数类似，其典型用法如下： 1double * temp = (double *)calloc(1000,sizeof(double)) calloc函数的参数是两个无符号整数，第一个参数是所需的存储单元数量，第二个参数是每个存储单元的大小。calloc函数有个特性，即在动态分配完内存后，自动初始化该内存空间为零，而malloc不初始化，里边数据是随机的垃圾数据。这是calloc与malloc最主要的区别。free函数也可以用于释放calloc分配的内存空间。 realloc函数当我们动态分配的内存不够了或者过大，我们可以使用realloc函数来调整内存的大小。其基本语法为： 指针名=（数据类型*）realloc(要改变内存大小的指针名，新的大小) 如果新的大小小于原内存大小，可能会导致数据的丢失；如果新的内存大小大于原内存大小，新分配的部分不会被初始化。 其原理时先判断当前指针是否有足够的连续内存空间，如果有则扩大当前地址，返回当前的指针；如果没有，则根据指定的内存大小重新寻找并分配内存空间，然后将原有数据全部拷贝至新的内存块，并自动释放原来的内存，然后返回新的内存块的首地址。 如果重新分配成功则返回指向被分配内存的指针，分配失败则返回空指针（NULL）。在函数结束时同样要使用free函数来释放内存空间。 参考资料 百度百科”realloc” 百度百科”malloc” 《C Primer Plus》（第6版）中文版]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pop Sequence]]></title>
    <url>%2FPop%20Sequence%2F</url>
    <content type="text"><![CDATA[Pop Sequence题目Given a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, …, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4. 输入格式Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M (the maximum capacity of the stack), N (the length of push sequence), and K (the number of pop sequences to be checked). Then T lines follow, each contains a pop sequence of N numbers. All the numbers in a line are separated by a space. 输出格式For each pop sequence, print in one line “YES“ if it is indeed a possible pop sequence of the stack, or “NO“ if not. 输入示例1234565 7 51 2 3 4 5 6 73 2 1 7 5 6 47 6 5 4 3 2 15 6 4 3 7 2 11 7 6 5 4 3 2 输出示例12345YESNONOYESNO 题目分析题目大意是给定一个入栈序列1，2，3，…，N，限定栈的大小为M，要求判断序列是否有可能从该栈输出。 例如题目所给的样例：5 6 4 3 7 2 1： 我们根据第一个出栈元素为5可以判断在5出栈前，1 2 3 4都应已入栈，则下一个应入栈元素是6。 根据第二个元素为6可知，6出栈前栈里的元素为1 2 3 4 6；下一个进栈元素是7。 根据第三个元素是4，第四个元素是3可知，7进栈前栈里的元素是1 2 ；7出栈后2，1分别出栈。整个过程符合1，2，3，…，N的入栈顺序，故该序列合法。 因此，若出现【栈顶元素大于待出栈的元素】或者【栈顶元素小于待出栈的元素】但【栈已满】的情况，则说明这个待出栈的元素是不可能出现的，据此可以判断该出栈序列不合法。 代码实现链表栈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;typedef struct node&#123; int *base; int top; int size;&#125;*stack;int m, n, t;stack CreateStack(int size)&#123; stack s = (stack)malloc(sizeof(struct node)); s-&gt;base = (int*)malloc(size * sizeof(int)); if (!s-&gt;base) &#123; cout &lt;&lt; "ERROR" &lt;&lt; endl; return 0; &#125; s-&gt;top = 0; s-&gt;size = size; return s;&#125;void push(stack s,int e)&#123; if (s-&gt;top == s-&gt;size)//栈已满 &#123; cout &lt;&lt; "FULL" &lt;&lt; endl; return ; &#125; s-&gt;base[++(s-&gt;top)] = e; return ;&#125;void pop(stack s)&#123; if (s-&gt;top == 0)//栈为空 &#123; cout &lt;&lt; "EMPTY" &lt;&lt; endl; return ; &#125; s-&gt;top--;&#125;int Check(int *array, stack s)&#123; int now = 1; int flag = 1; s-&gt;top = 0;//注意这里要重新设置栈顶位置 for (int i = 0; i &lt; n &amp;&amp; flag; i++) &#123; while ((s-&gt;base[s-&gt;top] != array[i] || s-&gt;top == 0)&amp;&amp;flag)//【栈为空】或【栈顶元素与待比较的出栈元素不等】 &#123; push(s, now); if (s-&gt;top==s-&gt;size &amp;&amp; s-&gt;base[s-&gt;top] != array[i]) //若【栈已满且栈顶元素仍然小于待比较的出栈元素】 &#123; flag = 0; break; &#125; now++; &#125; if ( flag &amp;&amp; s-&gt;base[s-&gt;top] == array[i] &amp;&amp; s-&gt;top &gt;= 1)//若【栈非空且栈顶元素等于待比较的出栈元素】 pop(s); &#125; if (flag) cout &lt;&lt; "YES" &lt;&lt; endl; else cout &lt;&lt; "NO" &lt;&lt; endl; return 1;&#125;int main()&#123; cin &gt;&gt; m &gt;&gt; n &gt;&gt; t; int *array = (int*)malloc(n * sizeof(int)); stack s = CreateStack(m); while (t--) &#123; for (int i = 0; i &lt; n; i++) cin &gt;&gt; array[i]; Check(array, s); &#125; free(s-&gt;base); free(array); return 0;&#125; 数组栈1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;using namespace std;int main()&#123; int m, n, t; cin &gt;&gt; m &gt;&gt; n &gt;&gt; t; int stack[1005];//栈 while (t--)//遍历每一个序列 &#123; int top = 0;//栈顶元素 int num;//待比较的出栈元素 int flag = 1;//判断标志 int now = 1; for (int i = 0; i &lt; n; i++)//遍历每一个数 &#123; cin &gt;&gt; num; while ((top == 0 || num != stack[top]) &amp;&amp; flag)//栈为空或者待出栈元素与栈顶元素不相等 &#123; stack[++top] = now; if (top &gt; m) &#123; flag = 0; break; &#125; now++; &#125; if (num == stack[top] &amp;&amp; flag &amp;&amp; top &gt;= 1)//栈不为空且...... &#123; top--; &#125; &#125; if (flag) printf("YES\n"); else printf("NO\n"); &#125;&#125;]]></content>
      <tags>
        <tag>习题</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String Task]]></title>
    <url>%2FString-Task%2F</url>
    <content type="text"><![CDATA[题目A. String TaskPetya started to attend programming lessons. On the first lesson his task was to write a simple program. The program was supposed to do the following: in the given string, consisting if uppercase and lowercase Latin letters, it: deletes all the vowels, inserts a character “.” before each consonant, replaces all uppercase consonants with corresponding lowercase ones. Vowels are letters “A”, “O”, “Y”, “E”, “U”, “I”, and the rest are consonants. The program’s input is exactly one string, it should return the output as a single string, resulting after the program’s processing the initial string. Help Petya cope with this easy task. InputThe first line represents input string of Petya’s program. This string only consists of uppercase and lowercase Latin letters and its length is from 1 to 100, inclusive. OutputPrint the resulting string. It is guaranteed that this string is not empty. 题解给定字符串，包含大小写的拉丁字母 删除所有元音， 在每个辅音之前插入“ . ”， 将所有大写辅音替换成相应的小写辅音； 元音字母包含 A，O，Y，E，U，I； 程序输入是一个字符串，它以单个字符串的形式返回输出，这是程序处理初始字符串后的结果 Input 第一行表示输入的字符串，改字符串仅由大写和小写拉丁字母组成，长度从0~100；Output打印结果字符串，可以保证这个字符串不为空。 思路​ 分别定义一个输入的字符串in[100]和输出的字符串ou[100]，将输出的字符串ou[100]的所有字符初始化为 ‘ . ‘ ；然后先将输入字符串的所有大写字母转换为小写；之后通过if语句判断是否为辅音字母；是辅音字母则间位提取至输出字符串ou[100]中。最后所得到的ou[100]则可以直接输出。 代码实现12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;int main()&#123; char in[100],ou[100]; for (int i = 0; i &lt; 100; i++) ou[i] = '.'; cin &gt;&gt;in; int j = 1, num = 0; for (int i = 0; i &lt; strlen(in);i++)//逐个查找 &#123; if (in[i] &gt;= 65 &amp;&amp; in[i] &lt;= 90) in[i] += 32;//将所有字母转换成小写 if (in[i] != 'a' &amp;&amp; in[i] != 'o' &amp;&amp; in[i] != 'y' &amp;&amp; in[i] != 'e' &amp;&amp; in[i] != 'u' &amp;&amp;in[i] != 'i') &#123; ou[j] = in[i]; num++; j += 2; &#125;//如果是辅音则间位提取 &#125; for (j = 0; j &lt; 2 * num; j++) cout &lt;&lt; ou[j]; cout &lt;&lt; endl; system("pause");&#125;]]></content>
      <tags>
        <tag>习题</tag>
      </tags>
  </entry>
</search>
