<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python学习笔记（三）——字符串及其输入与格式化输出]]></title>
    <url>%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8A%E5%85%B6%E8%BE%93%E5%85%A5%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[字符串简述字符串是Python中最常用的数据类型。在Python中，用引号括起来的都是字符串，其中引号可以是单引号，也可以是双引号。创建字符串很简单，只需要为变量分配一个值即可，例如：12str1 = 'Hello world !'str2 = "Welcome to Jacob's Blogs !"在Python中可以根据实际情况选择使用单引号或者双引号。例如当我们想在字符串中包含引号或撇号时：1234str1 = 'I told my friend, "Python is my favorite language!"'str2 = "The language 'Python' is named after Monty Python, not the snake."print(str1)print(str2)运行结果：12I told my friend, &quot;Python is my favorite language!&quot;The language &apos;Python&apos; is named after Monty Python, not the snake.字符串的输入Python2.x在 Python2.x 中 raw_input( ) 和input( )，两个函数都存在，其中区别为:raw_input( ) 将所有输入作为字符串看待，返回字符串类型。input( ) 只能接收”数字”的输入，在对待纯数字输入时具有自己的特性，它返回所输入的数字的类型（ int, float ）。注意：input() 和 raw_input() 这两个函数均能接收 字符串 ，但 raw_input() 直接读取控制台的输入（任何类型的输入它都可以接收）。而对于 input() ，它希望能够读取一个合法的 python 表达式，即你输入字符串的时候必须使用引号将它括起来，否则它会引发一个 SyntaxError 。除非对 input() 有特别需要，否则一般情况下都是推荐使用 raw_input() 来与用户交互。例如：123456789101112131415161718192021222324252627282930#Python2.x: input() 需要输入 python 表达式&gt;&gt;&gt;a = input("input:")input:123 # 输入整数&gt;&gt;&gt; type(a)&lt;type 'int'&gt; # 整型&gt;&gt;&gt; a = input("input:") input:"runoob" # 正确，字符串表达式&gt;&gt;&gt; type(a)&lt;type 'str'&gt; # 字符串&gt;&gt;&gt; a = input("input:")input:runoob # 报错，不是表达式Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;string&gt;", line 1, in &lt;module&gt;NameError: name 'runoob' is not defined&lt;type 'str'&gt;#Python2.x: raw_input() 将所有输入作为字符串看待&gt;&gt;&gt;a = raw_input("input:")input:123&gt;&gt;&gt; type(a)&lt;type 'str'&gt; # 字符串&gt;&gt;&gt; a = raw_input("input:")input:runoob&gt;&gt;&gt; type(a)&lt;type 'str'&gt; # 字符串&gt;&gt;&gt;Python3.xPython3.x对raw_input( ) 和 input( ) 进行了整合，去除了 raw_input( )，仅保留了 input( ) 函数，其接收任意输入，将所有输入默认为字符串处理，并返回字符串类型。例如：123456789101112131415# Python 3.2.3 &gt;&gt;&gt; user=raw_input("please input:") #没有了raw_input,因此报错Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;NameError: name 'raw_input' is not defined &gt;&gt;&gt; user=input("please input:")please input:wei&gt;&gt;&gt; user'wei'&gt;&gt;&gt; user=input("please input:") #input的输出结果都是作为字符串please input:123&gt;&gt;&gt; user'123'注意：python3 里 input() 默认接收到的是 str 类型。字符串的格式化输出各种符号字符串格式化符号：符号描述%c格式化字符及其ASCII码%s格式化字符串%d格式化整数%u格式化无符号整型%o格式化无符号八进制数%x格式化无符号十六进制数%X格式化无符号十六进制数（大写）%f格式化浮点数字，可指定小数点后的精度%e用科学计数法格式化浮点数%E作用同%e，用科学计数法格式化浮点数%g%f和%e的简写%G%f 和 %E 的简写%p用十六进制数格式化变量的地址字符串运算符操作符描述+字符串连接*重复输出字符串[]通过索引获取字符串中字符[ : ]截取字符串中的一部分，遵循左闭右开原则，str[0,2] 是不包含第 3 个字符的。in成员运算符 - 如果字符串中包含给定的字符返回 Truenot in成员运算符 - 如果字符串中不包含给定的字符返回Truer/R原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母 r（可以大小写）以外，与普通字符串有着几乎完全相同的语法。%格式字符串转义字符表转义字符描述\(在行尾时)续行符\\反斜杠符号\&#39;单引号\&quot;双引号\a响铃\b退格(Backspace)\000空\n换行\v纵向制表符\t横向制表符\r回车\f换页\oyy八进制数，yy代表的字符，例如：\o12代表换行\xyy十六进制数，yy代表的字符，例如：\x0a代表换行\other其它的字符以普通格式输出格式化输出格式表达式：%[(name)][flags][width][.precision]typecode1、(name)可选，用以选择指定的key。例：12&gt;&gt;&gt; "%(name)s is %(age)d" % &#123;"name":"Mike", "age":18&#125;'Mike is 18'2、flags可选，可选值为：+ 右对齐，正数前加号，负数前减号。- 左对齐，正数前无符号，负数前减号。空格 右对齐，正数前空格，负数前减号。0 右对齐，正数前无符号，负数前减号，用0填充空白处。例：12345678&gt;&gt;&gt; "%10s, %10d" % ('Hello', -1234) # 默认右对齐' Hello, -1234'&gt;&gt;&gt; "%+10d, %+10d" % (1234, -1234) # +，右对齐，显示符号' +1234, -1234'&gt;&gt;&gt; "%-10s, %-10d, %-10d" % ('Hello', 1234, -1234) # -，左对齐，不显示加号'Hello , 1234 , -1234'&gt;&gt;&gt; "%010s, %010d, %010d" % ('Hello',1234, -1234) # 0，右对齐，0是占位符' Hello, 0000001234, -000001234'3、width可选，占有宽度。4、.precision可选，小数点后保留位数。例：123456&gt;&gt;&gt; "%010.4f" % (5.0/3) # 10位，显示4位小数'00001.6667'&gt;&gt;&gt; "%.6f" % (5.0/3) # 显示6位小数'1.666667'&gt;&gt;&gt; "%010.f" % (5.0/3) # 不显示小数'0000000002'5、typecode,格式化字符，必选。字符串格式化符号：符号描述%c格式化字符及其ASCII码%s格式化字符串%d格式化整数%u格式化无符号整型%o格式化无符号八进制数%x格式化无符号十六进制数%X格式化无符号十六进制数（大写）%f格式化浮点数字，可指定小数点后的精度%e用科学计数法格式化浮点数%E作用同%e，用科学计数法格式化浮点数%g%f和%e的简写%G%f 和 %E 的简写%p用十六进制数格式化变量的地址示例：12345678910111213141516171819&gt;&gt;&gt; s = 'hello, %s!' % 'python'&gt;&gt;&gt; s'hello, python!'&gt;&gt;&gt; s = 'hello, %s, %d!' % ('python', 2018)&gt;&gt;&gt; s'hello, python, 2018!'&gt;&gt;&gt; s = 'hello, %(name)s, %(year)d!' % &#123;'name': 'python', 'year': 2018&#125;&gt;&gt;&gt; s'hello, python, 2018!'&gt;&gt;&gt; s = 'hello, %(name)+10s, %(year)-10d!' % &#123;'name': 'python', 'year': 2018&#125;&gt;&gt;&gt; s'hello, python, 2018 !'&gt;&gt;&gt; s = 'hello, %(name)s, %(year).3f!' % &#123;'name': 'python', 'year': 2018&#125;&gt;&gt;&gt; s'hello, python, 2018.000!'一些字符串运算符的使用字符串的拼接与截取在Python中，可以使用+符号将多个字符串连接起来显示，例如：123str1 = 'Hello'str2 = 'Jacob'print(str1 + " " + str2)运行结果：1Hello Jacob还可以使用[]符号索引获取字符串中的字符，或者通过[ : ]截取字符串中的一部分。注意：1、索引是从0开始的，即第一个字符的索引值为0。2、[a:b]中，a表示要显示的第一个字符的索引值，b表示要显示的总字符数。3、[:b]表示从第一个字符开始，输出b个字符。4、[a:]表示从第a+1个字符开始，输出到字符串末尾。5、空格同样是一个字符，不可忽略。例如：12345678str1 = 'Hello World'print ("str1[0]: ", str1[0])print ("str1[1]: ", str1[1])print ("str1[2]: ", str1[2])print ("str1[3]: ", str1[3])print ("str1[4]: ", str1[4])print ("str1[5]: ", str1[5])print ("str1[6]: ", str1[6])运行结果：1234567str1[0]: Hstr1[1]: estr1[2]: lstr1[3]: lstr1[4]: ostr1[5]:str1[6]: W123456str1 = 'Hello World'print ("str1[1:4]: ", str1[1:4])print ("str1[1:5]: ", str1[1:5])print ("str1[1:6]: ", str1[1:6])print ("str1[1:7]: ", str1[1:7])print ("str1[1:8]: ", str1[1:8])运行结果：12345str1[1:4]: ellstr1[1:5]: ellostr1[1:6]: ellostr1[1:7]: ello Wstr1[1:8]: ello Wo123456str1 = 'Hello World'print ("str1[:4]: ", str1[:4])print ("str1[:5]: ", str1[:5])print ("str1[3:]: ", str1[3:])print ("str1[4:]: ", str1[4:])运行结果：12345str1[:4]: Hellstr1[:5]: Hellostr1[3:]: lo Worldstr1[4:]: o World字符串的重复输出示例：12345&gt;&gt;&gt;str1='Hello'&gt;&gt;&gt;print(str1*2)HelloHello&gt;&gt;&gt;print("%s" % str1*2)HelloHello%s与%r的区别%r 用来做 debug 比较好，因为它会显示变量的原始数据（raw data），而其它的符号则是用来向用户显示输出的。123456789101112&gt;&gt;&gt; a = 'sunday'&gt;&gt;&gt; print("Today is %s" % a)Today is sunday&gt;&gt;&gt; print("Today is %r" % a)Today is 'sunday' # 格式化部分用单引号输出&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; d = datetime.now()&gt;&gt;&gt; print('%s' % d)2018-09-10 08:52:00.769949&gt;&gt;&gt; print('%r' % d)datetime.datetime(2018, 9, 10, 8, 52, 0, 769949) # 可以看见与上面输出存在明显的区别成员运算符的使用示例：123456789101112a = "Hello"b = "Python"if( "H" in a) : print("H 在变量 a 中")else : print("H 不在变量 a 中") if( "M" not in a) : print("M 不在变量 a 中")else : print("M 在变量 a 中")运行结果：12H 在变量 a 中M 不在变量 a 中]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动备份Hexo源文件]]></title>
    <url>%2F%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BDHexo%E6%BA%90%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言配置一个Hexo博客往往需要作者倾注大量心血，而如果哪天电脑坏了或者换电脑导致Hexo源文件丢失的话就是一件比较杯具的事。因此本文给出了一种自动备份Hexo源文件到Github的方法，能够在执行hexo deploy命令后自动执行Git命令以推送Hexo源文件到Github仓库。原理NodeJS的事件监听机制能够监听Hexo的事件。通过查询Hexo文档，找到了Hexo的主要事件，见下表：事件名描述deployBefore在部署完成前发布。deployAfter在部署成功后发布。exit在Hexo 结束前发布。generateBefore在静态文件生成前发布。generateAfter在静态文件生成后发布。new在文章文件建立后发布。该事件返回文章参数。processBefore在处理原始文件前发布。此事件会返回一个地址，代表 Box（Box）的根目录。processAfter在原始文件处理后发布。此事件会返回一个地址，代表 Box（Box）的根目录。ready在初始化完成后发布。通过查询上表发现，我们可以通过监听Hexo的deployAfter事件，待部署成功后自动运行Git备份命令，从而达到自动备份的目的。实现将Hexo目录加入Git仓库首先需要在Github创建一个新的repository,名字与本地Hexo文件夹同名即可。然后进入本地Hexo文件夹，按顺序执行以下命令：123git initgit remote add origin git@github.com:yourname/hexo.gitgit pull origin master再每次执行hexo generate命令时，public/、.deploy、*.log文件夹会重写更新，因此需要在.gitignore文件（如果没有，手动创建一个）中写入public/、.deploy、*.log以忽略这几个目录，加快备份的速度。然后再顺序执行以下命令，将文件推送到Github：123git add .git commit -m "备份hexo源码文件"git push origin master这三行命令便是手动推送本地文件到Github的命令,我们接下来要做的是让NodeJS监听到Hexo的deployAfter事件后自动执行上述命令。安装shelljs模块键入以下命令即可1npm install --save shelljs加入自动执行脚本在Hexo根目录的scripts文件夹（没有就自己创建一个）下新建一个js文件，文件名随意。然后加入以下代码：1234567891011121314151617181920212223242526272829303132333435require('shelljs/global');try &#123; hexo.on('deployAfter', function() &#123;//当deploy完成后执行备份 run(); &#125;);&#125; catch (e) &#123; console.log("产生了一个错误&lt;(￣3￣)&gt; !，错误详情为：" + e.toString());&#125;function run() &#123; if (!which('git')) &#123; echo('Sorry, this script requires git'); exit(1); &#125; else &#123; echo("======================Auto Backup Begin==========================="); cd('path to hexo'); //此处修改为Hexo根目录路径 if (exec('git add --all').code !== 0) &#123; echo('Error: Git add failed'); exit(1); &#125; if (exec('git commit -am "Form auto backup script\'s commit"').code !== 0) &#123; echo('Error: Git commit failed'); exit(1); &#125; if (exec('git push origin master').code !== 0) &#123; echo('Error: Git push failed'); exit(1); &#125; echo("==================Auto Backup Complete============================") &#125;&#125;注意上述代码中第29行需要修改为自己Hexo文件夹的绝对路径。效果如果脚本运行成功，会得到类似以下的效果：1234567891011121314======================Auto Backup Begin===========================cd: no such file or directory: ‪C:/Users/17810/OneDrive/hexowarning: LF will be replaced by CRLF in source/_posts/自动备份Hexo源文件.md.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in source/_posts/自动备份Hexo源文件.md.The file will have its original line endings in your working directory.[master a6cb4c7] Form auto backup script&apos;s commit 1 file changed, 153 insertions(+)warning: LF will be replaced by CRLF in source/_posts/自动备份Hexo源文件.md.The file will have its original line endings in your working directory.To git@github.com:JacobZjw/hexo.git 0beaf4c..a6cb4c7 master -&gt; master==================Auto Backup Complete============================懒癌患者的小福利在hexo中，我们常常使用hexo new命令来新建文章。然鹅，当我们的文章较多时，我们往往需要在成堆的文章中找到刚刚生成的文件，然后使用Markdown编辑器打开。作为一名懒癌患者怎么可能让自己如此受累。于是，我找到了Hexo作者给出的解决办法和上面类似，在scripts文件夹中创建一个js文件，添加以下代码：1234567891011var spawn = require('child_process').exec;// Hexo 2.x 用户复制这段hexo.on('new', function(path)&#123; spawn('start "markdown编辑器绝对路径.exe" ' + path);&#125;);// Hexo 3 用户复制这段hexo.on('new', function(data)&#123; spawn('start "markdown编辑器绝对路径.exe" ' + data.path);&#125;);保存并退出脚本之后，在命令行中键入：1hexo new &quot;auto open editor test&quot;是不是就顺利的自动打开了自动生成的md文件啦~]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记（二）——数字类型的运算及其输入与格式化输出]]></title>
    <url>%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BF%90%E7%AE%97%E5%8F%8A%E5%85%B6%E8%BE%93%E5%85%A5%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[数字类型Python中数字有四种类型：整数、布尔型、浮点数和复数。int (整型), 如 1, 只有一种整数类型 int，表示为长整型，没有python2 中的 long。bool (布尔型), 如True。float (浮点型), 如 1.23、3E-2complex (复数型), 如 1 + 2j、 1.1 + 2.2j整型Python中可以处理任意大小（即无限大小）的整数（Python 2.x中有int和long两种类型的整数，但这种区分对Python来说意义不大，因此在Python 3.x中整数只有int这一种了），而且支持二进制（如0b100，换算成十进制是4）、八进制（如0o100，换算成十进制是64）、十进制（100）和十六进制（0x100，换算成十进制是256）的表示法。布尔型布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来（例如3 &lt; 5会产生布尔值True，而2 == 1会产生布尔值False）。浮点型Python将带小数点的数字统称为浮点数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如123.456）之外还支持科学计数法（如1.23456e2）。复数型形如3+5j，跟数学上的复数表示一样，唯一不同的是虚部的i换成了j。运算符及运算算术运算符运算符描述+加——两个对象相加-减——一个数减去另一个数*乘——两个数相乘或者得到一个被重复若干次的字符串/除——x除以y%取模——返回除法的余数**幂——返回x的y次幂//取整数——返回商的余数示例：123456789a=121b=10print('%d + %d =\t%d' %(a,b,a+b))#相加print('%d - %d =\t%d' %(a,b,a-b))#相减print('%d * %d =\t%d' %(a,b,a*b))#相乘print('%d / %d = \t%f' % (a, b, a / b))#相除print('%d // %d = \t%d' % (a, b, a // b))#整除print('%d %% %d = \t%d' % (a, b, a % b))#取模print('%d ** %d = \t%d' % (a, b, a ** b))#幂运算结果：1234567121 + 10 = 131121 - 10 = 111121 * 10 = 1210121 / 10 = 12.100000121 // 10 = 12121 % 10 = 1121 ** 10 = 672749994932560009201赋值运算符运算符描述=c=a+b将a+b运算结果赋值为c+=c+=a等价于c=c+a-=c-=a等价于c=c-a*=c*=a等价于c=c*a/=c/=a等价于c=c/a%=c%=a等价于c=c%a**=c* * =a等价于c=c* *a//=c//=a等价于c=c//a逻辑运算符Python语言支持以下逻辑运算符。假设变量a的值为True，变量b的值为False，那么 -运算符描述示例and如果两个操作数都为真，则条件成立。(a and b)的结果为Falseor如果两个操作数中的任何一个非零，则条件成为真。(a or b)的结果为Truenot用于反转操作数的逻辑状态。not(a and b) 的结果为True示例：123456789101112flag1 = 3 &gt; 2flag2 = 2 &lt; 1flag3 = flag1 and flag2flag4 = flag1 or flag2flag5 = not flag1print("flag1 = ", flag1)print("flag2 = ", flag2)print("flag3 = ", flag3)print("flag4 = ", flag4)print("flag5 = ", flag5)print(flag1 is True)print(flag2 is not False)运算结果：1234567flag1 = Trueflag2 = Falseflag3 = Falseflag4 = Trueflag5 = FalseTrueFalse按位运算符设变量a=60,b=13;则二进制a表示为：00111100，b表示为：00001101运算符描述示例&amp;二进制与。如果它存在于两个操作数中，则操作符复制位到结果中(a &amp; b) 结果表示为 00001100``二进制或，如果它存在于任一操作数，则复制位。`(ab)=61结果表示为00111101`^二进制异或，如果它是一个操作数集合，但不是同时是两个操作数则将复制位。(a ^ b) = 49 结果表示为 00110001~二进制补码，它是一元的，具有“翻转”的效果。(~a ) = -61有符号的二进制数，表示为11000011的补码形式&lt;&lt;二进制左移，左操作数的值由右操作数指定的位数左移。a &lt;&lt; 2 = 240 结果表示为 11110000&gt;&gt;二进制右移，左操作数的值由右操作数指定的位数右移。a &gt;&gt; 2 = 15结果表示为00001111Python的内置函数bin()可用于获取整数的二进制表示形式。示例：12345678910111213141516171819202122a = 60 # 60 = 0011 1100b = 13 # 13 = 0000 1101print ('a=',a,':',bin(a),'b=',b,':',bin(b))c = 0c = a &amp; b; # 12 = 0000 1100print ("result of AND is ", c,':',bin(c))c = a | b; # 61 = 0011 1101 print ("result of OR is ", c,':',bin(c))c = a ^ b; # 49 = 0011 0001print ("result of EXOR is ", c,':',bin(c))c = ~a; # -61 = 1100 0011print ("result of COMPLEMENT is ", c,':',bin(c))c = a &lt;&lt; 2; # 240 = 1111 0000print ("result of LEFT SHIFT is ", c,':',bin(c))c = a &gt;&gt; 2; # 15 = 0000 1111print ("result of RIGHT SHIFT is ", c,':',bin(c))运算结果：1234567a= 60 : 0b111100 b= 13 : 0b1101result of AND is 12 : 0b1100result of OR is 61 : 0b111101result of EXOR is 49 : 0b110001result of COMPLEMENT is -61 : -0b111101result of LEFT SHIFT is 240 : 0b11110000result of RIGHT SHIFT is 15 : 0b1111成员运算符运算符描述in如果在指定的序列中找到一个变量的值，则返回true，否则返回false。not int如果在指定序列中找不到变量的值，则返回true，否则返回false。身份运算符运算符描述is如果运算符任一侧的变量指向相同的对象，则返回True，否则返回False。is not如果运算符任一侧的变量指向相同的对象，则返回True，否则返回False。基本输入与格式化输出输入使用input([prompt])读取一行，将其转换为string类型并返回。input的参数可有可无，如果有参数的话，会在控制台（可以这样理解）输出参数的内容，不换行。通常情况下我们在控制台输入一些数据，然后敲击回车，就完成了本次输入。示例：12name = input("Please enter your name: ")print(name)运算结果：12Please enter your name: JacobJacob这里要注意的是，input返回的是string类型，如果想输入数字，还需要进行类型转换，例如：12num = int(input("Enter a number: "))print(num*2)运算结果：12Enter a number: 48格式化输出Python字符串格式化符号：符号描述%c格式化字符及其ASCII码%s格式化字符串%d格式化整数%u格式化无符号整型%o格式化无符号八进制数%x格式化无符号十六进制数%X格式化无符号十六进制数（大写）%f格式化浮点数字，可指定小数点后的精度%e用科学计数法格式化浮点数%E作用同%e，用科学计数法格式化浮点数%g%f和%e的简写%G%f 和 %E 的简写%p用十六进制数格式化变量的地址格式化操作符辅助指令：符号功能*定义宽度或者小数点精度-用做左对齐+在正数前面显示加号( + )，在负数前面显示减号（-）&lt;sp&gt;在正数前面显示空格#在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’)0显示的数字前面填充’0’而不是默认的空格%‘%%’输出一个单一的’%’(var)映射变量(字典参数)m.n.m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)格式化输出整数示例：12345678a = 321b = 123print(a + b)print('%d + %d = %d' % (a, b, a + b))print('%d + %d = %+d' % (a, b, a + b))print('%d + %d = %06d' % (a, b, a + b))print('%d + %d = %.6d' % (a, b, a + b))print("a + b= ",a+b)运算结果：123456444321 + 123 = 444321 + 123 = +444321 + 123 = 000444321 + 123 = 000444a + b= 444格式化输出16进制，十进制，八进制整数#%x — hex 十六进制#%d — dec 十进制#%o — oct 八进制示例：1234nHex = 1024print("nHex = %x,nDec = %d,nOct = %o" %(nHex,nHex,nHex))nHex = 0xFFprint("nHex = %x,nDec = %d,nOct = %o" %(nHex,nHex,nHex))运算结果：12nHex = 400,nDec = 1024,nOct = 2000nHex = ff,nDec = 255,nOct = 377格式化输出浮点数示例：12345678pi = 3.141592653 print('%10.3f' % pi) #字段宽10，精度3 print("pi = %.*f" % (3,pi)) #用*从后面的元组中读取字段宽度或精度 print('%010.3f' % pi) #用0填充空白 print('%-10.3f' % pi) #左对齐 print('%+f' % pi) #显示正负号 pi = -piprint('%+f' % pi) #显示正负号运算结果：123456 3.142pi = 3.142000003.1423.142+3.141593-3.141593]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记（一）——学习资源及参考资料]]></title>
    <url>%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%8F%8A%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%2F</url>
    <content type="text"><![CDATA[环境：Python3基于Windows平台参考资料：《Python编程: 从入门到实践》 (美)EricMatthes,袁国忠——电子版传送门（提取码：269c）Python - 100天从新手到大师——Github传送门不定期更新中······]]></content>
      <categories>
        <category>学习资源</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Python</tag>
        <tag>学习资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VS Code配置C/C++]]></title>
    <url>%2FVS-Code%E9%85%8D%E7%BD%AEC%2B%2B%2F</url>
    <content type="text"><![CDATA[在开始安装之前，请先确认你满足以下几个条件。1、首先，你有一台电脑，并且已经连接到网络。（受你当前网速的影响，安装过程可能会花费10几分钟或1个小时以上的时间。）2、其次，你的电脑硬盘有500MB的剩余空间。下载MinGw-w64点击链接从sourceforge官网下载MinGw-w64点击图片中的“Download Latest Version”下载最新版本的MinGW-w64。安装MinGw-w64下载完成后，你会看到这样的窗口，猜猜点哪个！猜到正确答案的小朋友会看到这样的窗口!按照这个选然后你会看到这个：可以根据需要在红框内更改安装路径。如果不需要改安装路径直接点下一步即可。等待一会儿，等待的时间取决于你的网速，如果嫌太慢可以把电脑砸了。稍微等一会你就会看到这个窗口：这说明MinGw-w64已经下载完成：配置环境变量在此电脑图标处点击鼠标右键，选择属性：打开系统面板。!点击红框中的高级系统设置。点击环境变量选择红框中的Path后点击编辑点击编辑按钮，填入bin文件夹的路径 。bin文件夹在哪？找一找你MinGW-w64的安装目录。检查是否安装成功进入命令提示符界面输入gcc -v（命令提示符界面怎么进呢？你猜猜？），之后如果出现红框内的字符说明你已功德圆满了。安装VS Code怎么安装？安装CPPTools插件优秀的你已成功安装了VS Code，接下来依次点击即可：修改VS Code调试配置文件在系统任意位置新建一个文件夹，在VSCode打开该文件夹，然后新建一个CPP文件，写一个简单但是完整的代码，比如像我这样的。然后在.vscode文件夹下创建四个文件，文件名为：1234c_cpp_properties.jsonlaunch.jsonsettings.jsontasks.json每个文件下的代码如下：c_cpp_properties.json:(文件路径需修改)123456789101112131415161718192021222324252627&#123; "configurations": [ &#123; "name": "MinGW64", "intelliSenseMode": "gcc-x64", "compilerPath": "D:\\软件\\MinGW\\mingw64\\bin\\g++.exe", "includePath": [ "$&#123;workspaceFolder&#125;", "D:/软件/MinGW/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/**", "D:/软件/MinGW/mingw64/x86_64-w64-mingw32/include/**" ], "browse": &#123; "path": [ "$&#123;workspaceFolder&#125;", "D:/软件/MinGW/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/**", "D:/软件/MinGW/mingw64/x86_64-w64-mingw32/include/**" ] &#125;, "limitSymbolsToIncludedHeaders": true, "databaseFilename": "", "cStandard": "c11", "cppStandard": "c++17" &#125; ], "version": 4&#125;launch.json：123456789101112131415161718192021222324252627&#123; "version": "0.2.0", "configurations": [ &#123; "name": "C++ Launch (GDB)", // 配置名称，将会在启动配置的下拉菜单中显示 "type": "cppdbg", // 配置类型，这里只能为cppdbg "request": "launch", // 请求配置类型，可以为launch（启动）或attach（附加） "targetArchitecture": "x64", // 生成目标架构，一般为x86或x64 "program": "$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe", // 重点！将要进行调试的程序的路径 "args": [], // 程序调试时传递给程序的命令行参数，一般设为空即可 "stopAtEntry": false, // 设为true时程序将暂停在程序入口处，一般设置为false "cwd": "$&#123;workspaceRoot&#125;", // 调试程序时的工作目录，一般为$&#123;workspaceRoot&#125; "externalConsole": true, // 调试时是否显示控制台窗口，一般设置为true显示控制台 "internalConsoleOptions": "neverOpen", // 如果不设为neverOpen，调试时会跳到“调试控制台”选项卡", "MIMode": "gdb", // 指定连接的调试器 "miDebuggerPath": "D:\\软件\\MinGW\\mingw64\\bin\\gdb.exe", //重点！ 调试器路径 "setupCommands": [ &#123; "description": "Enable pretty-printing for GDB", "text": "-enable-pretty-printing", "ignoreFailures": false &#125; ], "preLaunchTask": "Compile" &#125; ]&#125;settings.json:123&#123; &quot;C_Cpp.intelliSenseEngineFallback&quot;: &quot;Enabled&quot;&#125;tasks.json:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#123; "version": "2.0.0", "tasks": [ &#123; "label": "Compile", "command": "g++", "args": [ "$&#123;file&#125;", //指定编译源代码文件 "-o", "$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe", //重点！ 指定输出文件名，不加该参数则默认输出a.exe "-ggdb3", // 生成和调试有关的信息 "-Wall", // 开启额外警告 "-static-libgcc", // 静态链接 "-std=c++17", // 使用c++17标准 "-finput-charset=UTF-8", //输入编译器文本编码 默认为UTF-8 "-fexec-charset=GBK", //输出exe文件的编码 "-D _USE_MATH_DEFINES" ], "problemMatcher": &#123; "owner": "cpp", "fileLocation": [ "absolute", ], "pattern": &#123; "regexp": "^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$", "file": 1, "line": 2, "column": 3, "severity": 4, "message": 5 &#125; &#125;, "type": "shell", "group": &#123; "kind": "build", "isDefault": true &#125;, "presentation": &#123; "echo": true, "reveal": "always", // 在“终端”中显示编译信息的策略，可以为always，silent，never "focus": false, "panel": "shared" // 不同的文件的编译信息共享一个终端面板 &#125;, &#125; ]&#125;配置完以上文件后，直接编译运行就可以了。如果遇到问题请留言，我会一一解答！]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>VS Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[malloc函数详解]]></title>
    <url>%2Fmalloc%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[函数定义及原理函数定义123extern void *malloc(unsigned int num_bytes);//函数原型#include&lt;stdlib.h&gt;//头文件void *malloc(size_t size);//函数声明原理malloc函数接收一个参数：所需的内存字节数。malloc会根据这个参数找到合适的空闲内存块，然后返回动态内存块的首字节地址。这个内存块是匿名的，malloc函数并不会为其赋名。因此我们需要将该地址赋值给一个指针变量，然后通过指针变量来访问这块内存。如果内存分配成功，malloc函数会返回一个（void*）类型的指针，在C、C++中规定该指针可以被强制转换成任何类型的指针，因此malloc函数可以用于返回指向数组的指针、指向结构的指针等而不用考虑类型匹配的问题。如果内存分配失败，则会返回空指针（NULL）。利用这个特性，我们必须在每次使用malloc函数后检查内存是否分配成功。使用malloc函数创建动态数组12double * ptd;ptd = (double*)malloc(30 * sizeof(double));这段代码中，malloc函数为30个double类型的值请求内存空间，然后使用强制类型转换将返回的指针转换成（double*）类型，然后赋值给ptd，即设置ptd指向所分配内存块的首元素。回忆数组的定义，数组名即为数组首元素的地址。我们将ptd指向内存块的首元素，便可以像使用数组名一样使用它。即用ptd[0]访问内存块的首元素，用ptd[1]访问内存块的第二个元素······利用这个方法可以创建动态数组1double ptd[n];通常我们执行程序时程序会报错（C99后可以使用），因此我们可以使用以下方法来创建动态数组：1double *ptd = ptd = (double*)malloc( n * sizeof(double));free函数内存泄漏在C语言中，通常把变量分为静态存储变量和动态存储变量两类。静态存储变量是指在程序运行期间分配了固定存储空间的变量；动态存储变量是指在程序运行期间根据实际需要进行动态地分配存储空间的变量。在内存中供用户使用的内存空间分为三部分：程序存储区静态存储区动态存储区程序中使用的数据分别存放在静态存储区和动态存储区中，静态存储区数据在程序的开始就分配好内存区。也就是说静态内存的数量在编译时时固定的，在程序运行期间也不会改变，在程序结束时自动释放。但是动态内存的数量只会增加，除非使用free进行释放。我们来看一段程序：1234567891011121314...int main()&#123; double glad[2000]; int i; ... for(int i=0;i&lt;1000;i++) gobble(glad,2000); ...&#125;void gobble(double ar[],int n)&#123; double * temp =(double*)malloc(n*sizeof(double));&#125;在第一次调用gobble函数时，它创建了一个指针temp，并为其分配了8*2000=16000字节的内存，在函数结束时，作为自动变量的指针temp会消失，但是系统并不会为我们自动释放这16000字节的内存。因此这块内存区域依旧存在，但由于temp指针已经消失，因此无法访问这块内存空间，同时它也无法被重复使用。主函数多次调用了gobble函数，当for循环执行结束，程序总共调用了1000次gobble函数，也就造成了16000000字节的内存被占用而无法使用，通常我们称这类问题为内存泄漏。为了避免这类问题，我们需要在函数末尾使用free函数来释放内存以避免这类问题的发生。使用方法free函数的参数是一个指针，即之前malloc函数返回的地址。使用时将其放在函数的末尾。例如上述代码添加free函数：12345void gobble(double ar[],int n)&#123; double * temp =(double*)malloc(n*sizeof(double)); free(temp);&#125;free函数使用的指针变量可以与malloc函数的指针变量不同，但是两个指针变量必须储存相同的地址。另外，如果被调函数使用malloc函数分配内存空间并返回指针供主调函数使用，则可以在主调函数末尾使用free函数通过该指针释放被调函数创建的内存空间，也就是说内存块可以在一个函数中创建，在另一个函数中销毁。需要注意的是，不能释放同一内存块两次。其他相关函数的使用calloc函数calloc函数功能与malloc函数类似，其典型用法如下：1double * temp = (double *)calloc(1000,sizeof(double))calloc函数的参数是两个无符号整数，第一个参数是所需的存储单元数量，第二个参数是每个存储单元的大小。calloc函数有个特性，即在动态分配完内存后，自动初始化该内存空间为零，而malloc不初始化，里边数据是随机的垃圾数据。这是calloc与malloc最主要的区别。free函数也可以用于释放calloc分配的内存空间。realloc函数当我们动态分配的内存不够了或者过大，我们可以使用realloc函数来调整内存的大小。其基本语法为：指针名=（数据类型*）realloc(要改变内存大小的指针名，新的大小)如果新的大小小于原内存大小，可能会导致数据的丢失；如果新的内存大小大于原内存大小，新分配的部分不会被初始化。其原理时先判断当前指针是否有足够的连续内存空间，如果有则扩大当前地址，返回当前的指针；如果没有，则根据指定的内存大小重新寻找并分配内存空间，然后将原有数据全部拷贝至新的内存块，并自动释放原来的内存，然后返回新的内存块的首地址。如果重新分配成功则返回指向被分配内存的指针，分配失败则返回空指针（NULL）。在函数结束时同样要使用free函数来释放内存空间。参考资料百度百科”realloc”百度百科”malloc”《C Primer Plus》（第6版）中文版]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pop Sequence]]></title>
    <url>%2FPop%20Sequence%2F</url>
    <content type="text"><![CDATA[Pop Sequence题目Given a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, …, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.输入格式Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M (the maximum capacity of the stack), N (the length of push sequence), and K (the number of pop sequences to be checked). Then T lines follow, each contains a pop sequence of N numbers. All the numbers in a line are separated by a space.输出格式For each pop sequence, print in one line “YES“ if it is indeed a possible pop sequence of the stack, or “NO“ if not.输入示例1234565 7 51 2 3 4 5 6 73 2 1 7 5 6 47 6 5 4 3 2 15 6 4 3 7 2 11 7 6 5 4 3 2输出示例12345YESNONOYESNO题目分析题目大意是给定一个入栈序列1，2，3，…，N，限定栈的大小为M，要求判断序列是否有可能从该栈输出。例如题目所给的样例：5 6 4 3 7 2 1：我们根据第一个出栈元素为5可以判断在5出栈前，1 2 3 4都应已入栈，则下一个应入栈元素是6。根据第二个元素为6可知，6出栈前栈里的元素为1 2 3 4 6；下一个进栈元素是7。根据第三个元素是4，第四个元素是3可知，7进栈前栈里的元素是1 2 ；7出栈后2，1分别出栈。整个过程符合1，2，3，…，N的入栈顺序，故该序列合法。因此，若出现【栈顶元素大于待出栈的元素】或者【栈顶元素小于待出栈的元素】但【栈已满】的情况，则说明这个待出栈的元素是不可能出现的，据此可以判断该出栈序列不合法。代码实现链表栈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;typedef struct node&#123; int *base; int top; int size;&#125;*stack;int m, n, t;stack CreateStack(int size)&#123; stack s = (stack)malloc(sizeof(struct node)); s-&gt;base = (int*)malloc(size * sizeof(int)); if (!s-&gt;base) &#123; cout &lt;&lt; "ERROR" &lt;&lt; endl; return 0; &#125; s-&gt;top = 0; s-&gt;size = size; return s;&#125;void push(stack s,int e)&#123; if (s-&gt;top == s-&gt;size)//栈已满 &#123; cout &lt;&lt; "FULL" &lt;&lt; endl; return ; &#125; s-&gt;base[++(s-&gt;top)] = e; return ;&#125;void pop(stack s)&#123; if (s-&gt;top == 0)//栈为空 &#123; cout &lt;&lt; "EMPTY" &lt;&lt; endl; return ; &#125; s-&gt;top--;&#125;int Check(int *array, stack s)&#123; int now = 1; int flag = 1; s-&gt;top = 0;//注意这里要重新设置栈顶位置 for (int i = 0; i &lt; n &amp;&amp; flag; i++) &#123; while ((s-&gt;base[s-&gt;top] != array[i] || s-&gt;top == 0)&amp;&amp;flag)//【栈为空】或【栈顶元素与待比较的出栈元素不等】 &#123; push(s, now); if (s-&gt;top==s-&gt;size &amp;&amp; s-&gt;base[s-&gt;top] != array[i]) //若【栈已满且栈顶元素仍然小于待比较的出栈元素】 &#123; flag = 0; break; &#125; now++; &#125; if ( flag &amp;&amp; s-&gt;base[s-&gt;top] == array[i] &amp;&amp; s-&gt;top &gt;= 1)//若【栈非空且栈顶元素等于待比较的出栈元素】 pop(s); &#125; if (flag) cout &lt;&lt; "YES" &lt;&lt; endl; else cout &lt;&lt; "NO" &lt;&lt; endl; return 1;&#125;int main()&#123; cin &gt;&gt; m &gt;&gt; n &gt;&gt; t; int *array = (int*)malloc(n * sizeof(int)); stack s = CreateStack(m); while (t--) &#123; for (int i = 0; i &lt; n; i++) cin &gt;&gt; array[i]; Check(array, s); &#125; free(s-&gt;base); free(array); return 0;&#125;数组栈1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;using namespace std;int main()&#123; int m, n, t; cin &gt;&gt; m &gt;&gt; n &gt;&gt; t; int stack[1005];//栈 while (t--)//遍历每一个序列 &#123; int top = 0;//栈顶元素 int num;//待比较的出栈元素 int flag = 1;//判断标志 int now = 1; for (int i = 0; i &lt; n; i++)//遍历每一个数 &#123; cin &gt;&gt; num; while ((top == 0 || num != stack[top]) &amp;&amp; flag)//栈为空或者待出栈元素与栈顶元素不相等 &#123; stack[++top] = now; if (top &gt; m) &#123; flag = 0; break; &#125; now++; &#125; if (num == stack[top] &amp;&amp; flag &amp;&amp; top &gt;= 1)//栈不为空且...... &#123; top--; &#125; &#125; if (flag) printf("YES\n"); else printf("NO\n"); &#125;&#125;]]></content>
      <categories>
        <category>习题</category>
      </categories>
      <tags>
        <tag>习题</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String Task]]></title>
    <url>%2FString-Task%2F</url>
    <content type="text"><![CDATA[题目A. String TaskPetya started to attend programming lessons. On the first lesson his task was to write a simple program. The program was supposed to do the following: in the given string, consisting if uppercase and lowercase Latin letters, it:deletes all the vowels,inserts a character “.” before each consonant,replaces all uppercase consonants with corresponding lowercase ones.Vowels are letters “A”, “O”, “Y”, “E”, “U”, “I”, and the rest are consonants. The program’s input is exactly one string, it should return the output as a single string, resulting after the program’s processing the initial string.Help Petya cope with this easy task.InputThe first line represents input string of Petya’s program. This string only consists of uppercase and lowercase Latin letters and its length is from 1 to 100, inclusive.OutputPrint the resulting string. It is guaranteed that this string is not empty.题解给定字符串，包含大小写的拉丁字母删除所有元音，在每个辅音之前插入“ . ”，将所有大写辅音替换成相应的小写辅音；元音字母包含 A，O，Y，E，U，I；程序输入是一个字符串，它以单个字符串的形式返回输出，这是程序处理初始字符串后的结果Input第一行表示输入的字符串，改字符串仅由大写和小写拉丁字母组成，长度从0~100；Output打印结果字符串，可以保证这个字符串不为空。思路​ 分别定义一个输入的字符串in[100]和输出的字符串ou[100]，将输出的字符串ou[100]的所有字符初始化为 ‘ . ‘ ；然后先将输入字符串的所有大写字母转换为小写；之后通过if语句判断是否为辅音字母；是辅音字母则间位提取至输出字符串ou[100]中。最后所得到的ou[100]则可以直接输出。代码实现12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;int main()&#123; char in[100],ou[100]; for (int i = 0; i &lt; 100; i++) ou[i] = '.'; cin &gt;&gt;in; int j = 1, num = 0; for (int i = 0; i &lt; strlen(in);i++)//逐个查找 &#123; if (in[i] &gt;= 65 &amp;&amp; in[i] &lt;= 90) in[i] += 32;//将所有字母转换成小写 if (in[i] != 'a' &amp;&amp; in[i] != 'o' &amp;&amp; in[i] != 'y' &amp;&amp; in[i] != 'e' &amp;&amp; in[i] != 'u' &amp;&amp;in[i] != 'i') &#123; ou[j] = in[i]; num++; j += 2; &#125;//如果是辅音则间位提取 &#125; for (j = 0; j &lt; 2 * num; j++) cout &lt;&lt; ou[j]; cout &lt;&lt; endl; system("pause");&#125;]]></content>
      <categories>
        <category>习题</category>
      </categories>
      <tags>
        <tag>习题</tag>
      </tags>
  </entry>
</search>
